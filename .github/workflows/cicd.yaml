name: Build and Deploy to GKE

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - stg
          - prd

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  REGION: ${{ secrets.GCP_REGION }}
  REPOSITORY: ${{ secrets.ARTIFACT_REGISTRY_REPO }}
  IMAGE_TAG: ${{ github.sha }}
  WIF_PROVIDER: ${{ secrets.WIF_PROVIDER }}
  WIF_SERVICE_ACCOUNT: ${{ secrets.WIF_SERVICE_ACCOUNT }}

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud using Workload Identity
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ env.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GCP Configuration
        id: gcp-config
        run: |
          PROJECT_ID=$(gcloud config get-value project)
          REGION=$(gcloud config get-value compute/region 2>/dev/null || echo "${{ env.REGION }}")
          ZONE=$(gcloud config get-value compute/zone 2>/dev/null || echo "${{ env.GKE_ZONE }}")
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "region=${REGION:-${{ env.REGION }}}" >> $GITHUB_OUTPUT
          echo "zone=${ZONE:-${{ env.GKE_ZONE }}}" >> $GITHUB_OUTPUT
          echo "Detected Project: $PROJECT_ID"
          echo "Detected Region: ${REGION:-${{ env.REGION }}}"
          echo "Detected Zone: ${ZONE:-${{ env.GKE_ZONE }}}"

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ steps.gcp-config.outputs.region }}-docker.pkg.dev

      - name: Build and push Poem Service
        working-directory: ./microservice-poem
        run: |
          REGION="${{ steps.gcp-config.outputs.region }}"
          PROJECT_ID="${{ steps.gcp-config.outputs.project_id }}"
          REPO="${{ steps.gcp-config.outputs.repo }}"
          TAG="${{ env.IMAGE_TAG }}"
          docker build -t ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/poem-service:${TAG} .
          docker tag ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/poem-service:${TAG} ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/poem-service:latest
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/poem-service:${TAG}
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/poem-service:latest

      - name: Build and push Quote Service
        working-directory: ./microservice-quote
        run: |
          REGION="${{ steps.gcp-config.outputs.region }}"
          PROJECT_ID="${{ steps.gcp-config.outputs.project_id }}"
          REPO="${{ steps.gcp-config.outputs.repo }}"
          TAG="${{ env.IMAGE_TAG }}"
          docker build -t ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/quote-service:${TAG} .
          docker tag ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/quote-service:${TAG} ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/quote-service:latest
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/quote-service:${TAG}
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/quote-service:latest

      - name: Build and push Frontend
        working-directory: ./frontend
        run: |
          REGION="${{ steps.gcp-config.outputs.region }}"
          PROJECT_ID="${{ steps.gcp-config.outputs.project_id }}"
          REPO="${{ steps.gcp-config.outputs.repo }}"
          TAG="${{ env.IMAGE_TAG }}"
          docker build -t ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/frontend:${TAG} .
          docker tag ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/frontend:${TAG} ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/frontend:latest
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/frontend:${TAG}
          docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO}/frontend:latest

  deploy:
    name: Deploy to GKE
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity
    strategy:
      matrix:
        environment: [dev, stg, prd]
    environment: ${{ matrix.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud using Workload Identity
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ env.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GCP Configuration
        id: gcp-config
        run: |
          PROJECT_ID=$(gcloud config get-value project)
          REGION=$(gcloud config get-value compute/region 2>/dev/null || echo "${{ env.REGION || 'us-central1' }}")
          ZONE=$(gcloud config get-value compute/zone 2>/dev/null || echo "${{ env.GKE_ZONE || 'us-central1-a' }}")
          REPO="${{ env.REPOSITORY || 'microservices' }}"
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "region=${REGION}" >> $GITHUB_OUTPUT
          echo "zone=${ZONE}" >> $GITHUB_OUTPUT
          echo "repo=${REPO}" >> $GITHUB_OUTPUT
          echo "Detected Project: $PROJECT_ID"
          echo "Detected Region: ${REGION}"
          echo "Detected Zone: ${ZONE}"
          echo "Repository: ${REPO}"

      - name: Set up kubectl
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --zone ${{ steps.gcp-config.outputs.zone }} \
            --project ${{ steps.gcp-config.outputs.project_id }}

      - name: Set environment variables
        id: env-vars
        run: |
          ENV="${{ matrix.environment }}"
          NAMESPACE="microservices-${ENV}"
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to environment: ${ENV}"
          echo "Namespace: ${NAMESPACE}"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.env-vars.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets
        run: |
          ENV="${{ matrix.environment }}"
          NAMESPACE="${{ steps.env-vars.outputs.namespace }}"
          
          # Use environment-specific secrets if available, otherwise use default
          POEM_SECRET_KEY="${{ secrets[format('POEM_API_SECRET_KEY_{0}', matrix.environment)] || secrets.POEM_API_SECRET_KEY }}"
          POEM_ADMIN_TOKEN="${{ secrets[format('POEM_ADMIN_TOKEN_{0}', matrix.environment)] || secrets.POEM_ADMIN_TOKEN }}"
          QUOTE_SECRET_KEY="${{ secrets[format('QUOTE_API_SECRET_KEY_{0}', matrix.environment)] || secrets.QUOTE_API_SECRET_KEY }}"
          QUOTE_ADMIN_TOKEN="${{ secrets[format('QUOTE_ADMIN_TOKEN_{0}', matrix.environment)] || secrets.QUOTE_ADMIN_TOKEN }}"
          
          kubectl create secret generic poem-secrets \
            --from-literal=API_SECRET_KEY="${POEM_SECRET_KEY}" \
            --from-literal=ADMIN_TOKEN="${POEM_ADMIN_TOKEN}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic quote-secrets \
            --from-literal=API_SECRET_KEY="${QUOTE_SECRET_KEY}" \
            --from-literal=ADMIN_TOKEN="${QUOTE_ADMIN_TOKEN}" \
            --namespace=${NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to GKE
        run: |
          ENV="${{ matrix.environment }}"
          NAMESPACE="${{ steps.env-vars.outputs.namespace }}"
          PROJECT_ID="${{ steps.gcp-config.outputs.project_id }}"
          REGION="${{ steps.gcp-config.outputs.region }}"
          REPO="${{ steps.gcp-config.outputs.repo }}"
          TAG="${{ env.IMAGE_TAG }}"
          
          # Create temporary directory for environment-specific manifests
          mkdir -p k8s-temp
          cp -r k8s/* k8s-temp/
          
          # Replace placeholders in manifests
          find k8s-temp -type f -name "*.yaml" -exec sed -i "s|IMAGE_TAG|${TAG}|g" {} \;
          find k8s-temp -type f -name "*.yaml" -exec sed -i "s|PROJECT_ID|${PROJECT_ID}|g" {} \;
          find k8s-temp -type f -name "*.yaml" -exec sed -i "s|REGION|${REGION}|g" {} \;
          find k8s-temp -type f -name "*.yaml" -exec sed -i "s|NAMESPACE|${NAMESPACE}|g" {} \;
          
          # Apply manifests
          kubectl apply -f k8s-temp/namespace.yaml
          kubectl apply -f k8s-temp/secrets.yaml
          kubectl apply -f k8s-temp/configmap.yaml
          kubectl apply -f k8s-temp/poem-deployment.yaml
          kubectl apply -f k8s-temp/quote-deployment.yaml
          kubectl apply -f k8s-temp/frontend-deployment.yaml
          kubectl apply -f k8s-temp/ingress.yaml

      - name: Verify deployment
        run: |
          NAMESPACE="${{ steps.env-vars.outputs.namespace }}"
          kubectl rollout status deployment/poem-service -n ${NAMESPACE} --timeout=5m
          kubectl rollout status deployment/quote-service -n ${NAMESPACE} --timeout=5m
          kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=5m
          kubectl get pods -n ${NAMESPACE}
          echo "âœ“ Deployment to ${{ matrix.environment }} environment completed successfully"